{
  "tasks": [
    {
      "id": 1,
      "title": "Update Startup.cs for MSAL Configuration",
      "description": "Modify the Startup.cs file to configure MSAL authentication alongside existing authentication methods",
      "details": "1. Install required NuGet packages: Microsoft.Identity.Web and Microsoft.Identity.Web.UI\n2. Update ConfigureServices method to add MSAL support:\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    // Existing authentication configuration\n    \n    // Add MSAL support\n    services.AddMicrosoftIdentityWebApiAuthentication(Configuration, \"AzureAd\");\n    \n    // Configure JWT options to support both auth methods\n    services.Configure<JwtBearerOptions>(JwtBearerDefaults.AuthenticationScheme, options =>\n    {\n        // Existing JWT configuration\n        \n        // Add event handlers for MSAL token validation\n        options.Events = new JwtBearerEvents\n        {\n            OnTokenValidated = async context => \n            {\n                // Token validation logic will be implemented in AuthService\n                var authService = context.HttpContext.RequestServices.GetRequiredService<IAuthService>();\n                await authService.ValidateTokenAsync(context);\n            }\n        };\n    });\n}\n```\n3. Update appsettings.json to include MSAL configuration:\n```json\n{\n  \"AzureAd\": {\n    \"Instance\": \"https://login.microsoftonline.com/\",\n    \"TenantId\": \"your-tenant-id\",\n    \"ClientId\": \"c67bf91d-8b6a-494a-8b99-c7a4592e08c1\",\n    \"CallbackPath\": \"/signin-oidc\"\n  },\n  // Existing configuration\n}\n```",
      "testStrategy": "1. Verify that the application builds successfully after the changes\n2. Ensure that the application starts without errors\n3. Check that both authentication configurations are loaded correctly\n4. Verify that the JWT bearer options are configured correctly\n5. Use logging to confirm the configuration is loaded as expected",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Create Authentication Middleware for Token Type Detection",
      "description": "Implement middleware to detect and handle different token types (MSAL vs legacy)",
      "details": "1. Create a new middleware class:\n```csharp\npublic class AuthenticationTypeMiddleware\n{\n    private readonly RequestDelegate _next;\n\n    public AuthenticationTypeMiddleware(RequestDelegate next)\n    {\n        _next = next;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        // Check for Authorization header\n        if (context.Request.Headers.ContainsKey(\"Authorization\"))\n        {\n            var authHeader = context.Request.Headers[\"Authorization\"].ToString();\n            if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith(\"Bearer \"))\n            {\n                var token = authHeader.Substring(\"Bearer \".Length).Trim();\n                \n                // Determine token type (MSAL vs Legacy)\n                bool isMsalToken = IsMsalToken(token);\n                \n                // Add token type to HttpContext items for later use\n                context.Items[\"IsMsalToken\"] = isMsalToken;\n            }\n        }\n\n        await _next(context);\n    }\n\n    private bool IsMsalToken(string token)\n    {\n        try\n        {\n            // Decode JWT token without validation\n            var handler = new JwtSecurityTokenHandler();\n            var jsonToken = handler.ReadToken(token) as JwtSecurityToken;\n\n            // MSAL tokens typically have specific claims or issuers\n            // Check for MSAL-specific indicators\n            return jsonToken?.Issuer?.Contains(\"login.microsoftonline.com\") == true ||\n                   jsonToken?.Claims?.Any(c => c.Type == \"aud\" && \n                                              c.Value == \"c67bf91d-8b6a-494a-8b99-c7a4592e08c1\") == true;\n        }\n        catch\n        {\n            // If token can't be parsed, assume it's not MSAL\n            return false;\n        }\n    }\n}\n\n// Extension method for easy middleware registration\npublic static class AuthenticationTypeMiddlewareExtensions\n{\n    public static IApplicationBuilder UseAuthenticationTypeDetection(\n        this IApplicationBuilder builder)\n    {\n        return builder.UseMiddleware<AuthenticationTypeMiddleware>();\n    }\n}\n```\n2. Register the middleware in Startup.cs Configure method:\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    // Other middleware\n    \n    // Add our custom middleware before authentication\n    app.UseAuthenticationTypeDetection();\n    \n    app.UseAuthentication();\n    app.UseAuthorization();\n    \n    // Rest of the configuration\n}\n```",
      "testStrategy": "1. Create unit tests for the IsMsalToken method with sample tokens\n2. Test the middleware with mock HttpContext and various Authorization headers\n3. Verify that the middleware correctly identifies MSAL tokens\n4. Ensure the middleware adds the correct token type to HttpContext.Items\n5. Test with invalid tokens to ensure proper error handling",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Update AuthService for Dual Authentication Support",
      "description": "Enhance the existing AuthService to support both MSAL and legacy authentication methods",
      "details": "1. Update the IAuthService interface:\n```csharp\npublic interface IAuthService\n{\n    // Existing methods\n    \n    // New methods for MSAL support\n    Task ValidateTokenAsync(TokenValidatedContext context);\n    Task<ClaimsPrincipal> ValidateMsalTokenAsync(string token);\n    Task<ClaimsPrincipal> ValidateLegacyTokenAsync(string token);\n}\n```\n\n2. Implement the updated AuthService:\n```csharp\npublic class AuthService : IAuthService\n{\n    private readonly IConfiguration _configuration;\n    private readonly ILogger<AuthService> _logger;\n    \n    public AuthService(IConfiguration configuration, ILogger<AuthService> logger)\n    {\n        _configuration = configuration;\n        _logger = logger;\n    }\n    \n    // Implement existing methods\n    \n    // Implement new methods\n    public async Task ValidateTokenAsync(TokenValidatedContext context)\n    {\n        try\n        {\n            // Check if token type was determined by middleware\n            if (context.HttpContext.Items.TryGetValue(\"IsMsalToken\", out var isMsalTokenObj) && \n                isMsalTokenObj is bool isMsalToken)\n            {\n                if (isMsalToken)\n                {\n                    _logger.LogInformation(\"Validating MSAL token\");\n                    // MSAL tokens are already validated by the framework\n                    // Additional custom validation can be added here if needed\n                }\n                else\n                {\n                    _logger.LogInformation(\"Validating legacy token\");\n                    // Perform legacy token validation\n                    // This would call into your existing validation logic\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error validating token\");\n            context.Fail(\"Token validation failed\");\n        }\n    }\n    \n    public async Task<ClaimsPrincipal> ValidateMsalTokenAsync(string token)\n    {\n        // This method would be used when you need to manually validate an MSAL token\n        // Microsoft.Identity.Web handles most validation automatically\n        \n        var validationParameters = new TokenValidationParameters\n        {\n            ValidateIssuer = true,\n            ValidIssuer = $\"https://login.microsoftonline.com/{_configuration[\"AzureAd:TenantId\"]}/v2.0\",\n            ValidateAudience = true,\n            ValidAudience = _configuration[\"AzureAd:ClientId\"],\n            ValidateLifetime = true,\n            ClockSkew = TimeSpan.FromMinutes(5),\n            ValidateIssuerSigningKey = true,\n            IssuerSigningKeys = await GetMsalSigningKeysAsync()\n        };\n        \n        var handler = new JwtSecurityTokenHandler();\n        var principal = handler.ValidateToken(token, validationParameters, out _);\n        return principal;\n    }\n    \n    public async Task<ClaimsPrincipal> ValidateLegacyTokenAsync(string token)\n    {\n        // Call into existing legacy token validation logic\n        // This would use your current validation parameters and logic\n        \n        // Example (replace with your actual implementation):\n        var validationParameters = new TokenValidationParameters\n        {\n            // Your existing validation parameters\n        };\n        \n        var handler = new JwtSecurityTokenHandler();\n        var principal = handler.ValidateToken(token, validationParameters, out _);\n        return principal;\n    }\n    \n    private async Task<IEnumerable<SecurityKey>> GetMsalSigningKeysAsync()\n    {\n        // Fetch OpenID configuration and signing keys from Microsoft\n        var tenantId = _configuration[\"AzureAd:TenantId\"];\n        var openIdConfigUrl = $\"https://login.microsoftonline.com/{tenantId}/v2.0/.well-known/openid-configuration\";\n        \n        using var httpClient = new HttpClient();\n        var openIdConfig = await httpClient.GetFromJsonAsync<OpenIdConnectConfiguration>(openIdConfigUrl);\n        return openIdConfig.SigningKeys;\n    }\n}\n\n// Helper class for OpenID configuration\npublic class OpenIdConnectConfiguration\n{\n    [JsonPropertyName(\"jwks_uri\")]\n    public string JwksUri { get; set; }\n    \n    // Other properties as needed\n    \n    public ICollection<SecurityKey> SigningKeys { get; } = new List<SecurityKey>();\n}\n```",
      "testStrategy": "1. Create unit tests for each new method in the AuthService\n2. Test ValidateTokenAsync with both MSAL and legacy token scenarios\n3. Mock the HttpContext and TokenValidatedContext for testing\n4. Test error handling scenarios\n5. Verify that the correct validation path is taken based on token type\n6. Test with actual MSAL tokens in a controlled environment",
      "priority": "medium",
      "dependencies": [
        1,
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement MSAL-Specific Token Validation Logic",
      "description": "Create specialized validation logic for MSAL tokens to ensure proper authentication",
      "details": "1. Create a dedicated MSAL token validator class:\n```csharp\npublic class MsalTokenValidator\n{\n    private readonly IConfiguration _configuration;\n    private readonly IMemoryCache _cache;\n    private readonly ILogger<MsalTokenValidator> _logger;\n    \n    public MsalTokenValidator(IConfiguration configuration, IMemoryCache cache, ILogger<MsalTokenValidator> logger)\n    {\n        _configuration = configuration;\n        _cache = cache;\n        _logger = logger;\n    }\n    \n    public async Task<(bool isValid, ClaimsPrincipal principal)> ValidateTokenAsync(string token)\n    {\n        try\n        {\n            var validationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidIssuers = new[] \n                { \n                    $\"https://login.microsoftonline.com/{_configuration[\"AzureAd:TenantId\"]}/v2.0\",\n                    $\"https://sts.windows.net/{_configuration[\"AzureAd:TenantId\"]}/\"\n                },\n                ValidateAudience = true,\n                ValidAudience = _configuration[\"AzureAd:ClientId\"],\n                ValidateLifetime = true,\n                ClockSkew = TimeSpan.FromMinutes(5),\n                ValidateIssuerSigningKey = true,\n                IssuerSigningKeys = await GetSigningKeysAsync()\n            };\n            \n            var handler = new JwtSecurityTokenHandler();\n            var principal = handler.ValidateToken(token, validationParameters, out var validatedToken);\n            \n            // Additional custom validation if needed\n            // For example, check for required claims\n            if (!principal.HasClaim(c => c.Type == \"oid\") && !principal.HasClaim(c => c.Type == \"sub\"))\n            {\n                _logger.LogWarning(\"MSAL token missing required identity claims\");\n                return (false, null);\n            }\n            \n            return (true, principal);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"MSAL token validation failed\");\n            return (false, null);\n        }\n    }\n    \n    private async Task<IEnumerable<SecurityKey>> GetSigningKeysAsync()\n    {\n        // Try to get signing keys from cache first\n        const string cacheKey = \"MsalSigningKeys\";\n        if (_cache.TryGetValue(cacheKey, out IEnumerable<SecurityKey> cachedKeys))\n        {\n            return cachedKeys;\n        }\n        \n        // Fetch OpenID configuration and signing keys from Microsoft\n        var tenantId = _configuration[\"AzureAd:TenantId\"];\n        var openIdConfigUrl = $\"https://login.microsoftonline.com/{tenantId}/v2.0/.well-known/openid-configuration\";\n        \n        using var httpClient = new HttpClient();\n        var openIdConfigJson = await httpClient.GetStringAsync(openIdConfigUrl);\n        var openIdConfig = JsonDocument.Parse(openIdConfigJson);\n        \n        var jwksUri = openIdConfig.RootElement.GetProperty(\"jwks_uri\").GetString();\n        var jwksJson = await httpClient.GetStringAsync(jwksUri);\n        \n        var jwks = new JsonWebKeySet(jwksJson);\n        var keys = jwks.Keys.Select(k => (SecurityKey)k).ToList();\n        \n        // Cache the keys (typically good for 24 hours)\n        _cache.Set(cacheKey, keys, TimeSpan.FromHours(24));\n        \n        return keys;\n    }\n}\n```\n\n2. Register the validator in Startup.cs:\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    // Existing configuration\n    \n    // Register the MSAL token validator\n    services.AddSingleton<MsalTokenValidator>();\n    \n    // Ensure memory cache is registered\n    services.AddMemoryCache();\n}\n```\n\n3. Update the AuthService to use the validator:\n```csharp\npublic class AuthService : IAuthService\n{\n    private readonly MsalTokenValidator _msalTokenValidator;\n    // Other dependencies\n    \n    public AuthService(MsalTokenValidator msalTokenValidator, /* other dependencies */)\n    {\n        _msalTokenValidator = msalTokenValidator;\n        // Initialize other dependencies\n    }\n    \n    public async Task ValidateTokenAsync(TokenValidatedContext context)\n    {\n        // Get the token from the context\n        var token = context.SecurityToken as JwtSecurityToken;\n        if (token == null) return;\n        \n        // Check if it's an MSAL token\n        if (context.HttpContext.Items.TryGetValue(\"IsMsalToken\", out var isMsalTokenObj) && \n            isMsalTokenObj is bool isMsalToken && isMsalToken)\n        {\n            // Perform additional MSAL-specific validation if needed\n            var (isValid, principal) = await _msalTokenValidator.ValidateTokenAsync(token.RawData);\n            if (!isValid)\n            {\n                context.Fail(\"MSAL token validation failed\");\n                return;\n            }\n            \n            // You could potentially replace the principal if needed\n            // context.Principal = principal;\n        }\n        else\n        {\n            // Legacy token validation logic\n        }\n    }\n    \n    // Other methods\n}\n```",
      "testStrategy": "1. Create unit tests for the MsalTokenValidator class\n2. Test with valid and invalid MSAL tokens\n3. Mock the HTTP responses for OpenID configuration and JWKS\n4. Test caching behavior for signing keys\n5. Verify that token validation correctly identifies valid and invalid tokens\n6. Test with expired tokens, tokens with invalid signatures, and tokens with missing claims\n7. Verify integration with the AuthService",
      "priority": "medium",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Update User Model for MSAL Identity Information",
      "description": "Enhance the user model to extract and store identity information from MSAL tokens",
      "details": "1. Update the User model to include MSAL-specific properties:\n```csharp\npublic class User\n{\n    // Existing properties\n    \n    // MSAL-specific properties\n    public string ObjectId { get; set; } // Maps to 'oid' claim\n    public string TenantId { get; set; } // Maps to 'tid' claim\n    public string PreferredUsername { get; set; } // Maps to 'preferred_username' claim\n    public bool IsAuthenticatedWithMsal { get; set; }\n    \n    // Method to create user from claims\n    public static User FromClaimsPrincipal(ClaimsPrincipal principal, bool isMsalAuth = false)\n    {\n        if (principal == null) return null;\n        \n        var user = new User\n        {\n            IsAuthenticatedWithMsal = isMsalAuth\n        };\n        \n        // Fill common properties\n        user.Username = principal.FindFirstValue(ClaimTypes.Name) ?? \n                       principal.FindFirstValue(\"preferred_username\") ?? \n                       principal.FindFirstValue(\"upn\");\n                       \n        user.Email = principal.FindFirstValue(ClaimTypes.Email) ?? \n                    principal.FindFirstValue(\"email\") ?? \n                    principal.FindFirstValue(\"preferred_username\");\n        \n        // Fill MSAL-specific properties if authenticated with MSAL\n        if (isMsalAuth)\n        {\n            user.ObjectId = principal.FindFirstValue(\"oid\") ?? principal.FindFirstValue(\"sub\");\n            user.TenantId = principal.FindFirstValue(\"tid\");\n            user.PreferredUsername = principal.FindFirstValue(\"preferred_username\");\n        }\n        else\n        {\n            // Map legacy claims if needed\n        }\n        \n        return user;\n    }\n}\n```\n\n2. Create a UserService to handle user creation and retrieval:\n```csharp\npublic interface IUserService\n{\n    User GetUserFromPrincipal(ClaimsPrincipal principal, bool isMsalAuth = false);\n    Task<User> GetOrCreateUserAsync(ClaimsPrincipal principal, bool isMsalAuth = false);\n}\n\npublic class UserService : IUserService\n{\n    private readonly IUserRepository _userRepository;\n    private readonly ILogger<UserService> _logger;\n    \n    public UserService(IUserRepository userRepository, ILogger<UserService> logger)\n    {\n        _userRepository = userRepository;\n        _logger = logger;\n    }\n    \n    public User GetUserFromPrincipal(ClaimsPrincipal principal, bool isMsalAuth = false)\n    {\n        return User.FromClaimsPrincipal(principal, isMsalAuth);\n    }\n    \n    public async Task<User> GetOrCreateUserAsync(ClaimsPrincipal principal, bool isMsalAuth = false)\n    {\n        var user = GetUserFromPrincipal(principal, isMsalAuth);\n        if (user == null) return null;\n        \n        // For MSAL users, try to find by ObjectId\n        if (isMsalAuth && !string.IsNullOrEmpty(user.ObjectId))\n        {\n            var existingUser = await _userRepository.GetByObjectIdAsync(user.ObjectId);\n            if (existingUser != null)\n            {\n                // Update properties if needed\n                existingUser.PreferredUsername = user.PreferredUsername;\n                existingUser.Email = user.Email;\n                await _userRepository.UpdateAsync(existingUser);\n                return existingUser;\n            }\n        }\n        \n        // Try to find by username/email for both auth types\n        var userByUsername = await _userRepository.GetByUsernameAsync(user.Username);\n        if (userByUsername != null)\n        {\n            // Update with MSAL info if needed\n            if (isMsalAuth && string.IsNullOrEmpty(userByUsername.ObjectId))\n            {\n                userByUsername.ObjectId = user.ObjectId;\n                userByUsername.TenantId = user.TenantId;\n                userByUsername.IsAuthenticatedWithMsal = true;\n                await _userRepository.UpdateAsync(userByUsername);\n            }\n            return userByUsername;\n        }\n        \n        // Create new user if not found\n        await _userRepository.CreateAsync(user);\n        return user;\n    }\n}\n```\n\n3. Register the service in Startup.cs:\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    // Existing configuration\n    \n    // Register user service\n    services.AddScoped<IUserService, UserService>();\n}\n```\n\n4. Update the AuthService to use the UserService:\n```csharp\npublic class AuthService : IAuthService\n{\n    private readonly IUserService _userService;\n    // Other dependencies\n    \n    public AuthService(IUserService userService, /* other dependencies */)\n    {\n        _userService = userService;\n        // Initialize other dependencies\n    }\n    \n    public async Task ValidateTokenAsync(TokenValidatedContext context)\n    {\n        // Existing validation logic\n        \n        // After successful validation, get or create the user\n        bool isMsalToken = context.HttpContext.Items.TryGetValue(\"IsMsalToken\", out var msalTokenObj) && \n                          msalTokenObj is bool msalToken && msalToken;\n        \n        var user = await _userService.GetOrCreateUserAsync(context.Principal, isMsalToken);\n        if (user != null)\n        {\n            // Add user to HttpContext for later use\n            context.HttpContext.Items[\"CurrentUser\"] = user;\n        }\n    }\n    \n    // Other methods\n}\n```",
      "testStrategy": "1. Create unit tests for the User.FromClaimsPrincipal method\n2. Test with both MSAL and legacy claims\n3. Create unit tests for UserService methods\n4. Mock the IUserRepository for testing\n5. Test user creation, retrieval, and updating scenarios\n6. Verify that MSAL-specific properties are correctly extracted from claims\n7. Test the integration with AuthService\n8. Verify that users can be correctly identified regardless of authentication method",
      "priority": "low",
      "dependencies": [
        3,
        4
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}