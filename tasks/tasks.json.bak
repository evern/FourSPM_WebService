{
  "tasks": [
    {
      "id": 1,
      "title": "Configure Azure AD Integration",
      "description": "Set up the application to connect with Azure AD tenant using the specified IDs and OAuth scopes.",
      "details": "1. Register the application in Azure AD portal if not already done\n2. Configure the application with:\n   - Tenant ID: 3c7fa9e9-64e7-443c-905a-d9134ca00da9\n   - Application (client) ID: c67bf91d-8b6a-494a-8b99-c7a4592e08c1\n3. Set up OAuth scopes:\n   - api://c67bf91d-8b6a-494a-8b99-c7a4592e08c1/Application.Admin\n   - api://c67bf91d-8b6a-494a-8b99-c7a4592e08c1/Application.User\n4. Create environment-specific configurations in appsettings.json:\n```json\n{\n  \"AzureAd\": {\n    \"Instance\": \"https://login.microsoftonline.com/\",\n    \"TenantId\": \"3c7fa9e9-64e7-443c-905a-d9134ca00da9\",\n    \"ClientId\": \"c67bf91d-8b6a-494a-8b99-c7a4592e08c1\",\n    \"CallbackPath\": \"/signin-oidc\",\n    \"SignedOutCallbackPath\": \"/signout-callback-oidc\"\n  }\n}\n```",
      "testStrategy": "1. Verify Azure AD configuration in Azure portal\n2. Confirm application registration details match the PRD specifications\n3. Validate OAuth scopes are correctly configured\n4. Test environment-specific configurations load correctly in different environments",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Register Application in Azure Portal",
          "description": "Sign in to the Azure portal with administrator privileges and create a new app registration. Record the Application (client) ID, Directory (tenant) ID, and configure the Redirect URI as required for your application.",
          "dependencies": [],
          "details": "Ensure you have the necessary Azure administrator role (Global Administrator, Cloud Application Administrator, or Application Administrator). Follow the Azure portal workflow to register the application and note all relevant credentials for later steps.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Configure OAuth Scopes and Permissions",
          "description": "Define and assign the necessary OAuth 2.0 scopes and API permissions for the registered application to enable secure access to required resources.",
          "dependencies": [
            1
          ],
          "details": "In the Azure portal, navigate to the app registration and configure API permissions. Add delegated or application permissions as needed, and grant admin consent if required.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Set Up Environment-Specific Configuration",
          "description": "Configure environment-specific settings such as client secrets, issuer URLs, and redirect URIs for each deployment environment (development, staging, production).",
          "dependencies": [
            2
          ],
          "details": "Store sensitive values like client secrets securely (e.g., Azure Key Vault or environment variables). Ensure each environment uses the correct configuration values to prevent authentication issues.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Authentication Middleware",
          "description": "Integrate authentication middleware in the application codebase to handle Azure AD authentication flows using the registered app and configured OAuth scopes.",
          "dependencies": [
            3
          ],
          "details": "Use appropriate libraries or frameworks (e.g., Microsoft.Identity.Web for .NET) to implement middleware that manages sign-in, token acquisition, and user session handling.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Test and Validate Azure AD Integration",
          "description": "Perform comprehensive testing of the Azure AD integration across all environments to ensure authentication works as expected and security requirements are met.",
          "dependencies": [
            4
          ],
          "details": "Test user sign-in, token issuance, scope enforcement, and error handling. Validate configuration for each environment and review logs for any authentication failures.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Entity Framework Models for Role and Permission",
      "description": "Create Entity Framework models for the ROLE and ROLE_PERMISSION tables with appropriate relationships and configurations.",
      "details": "1. Create Role entity class:\n```csharp\npublic class Role\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string DisplayName { get; set; }\n    public string Description { get; set; }\n    public bool IsSystemRole { get; set; }\n    \n    // Navigation property\n    public virtual ICollection<RolePermission> RolePermissions { get; set; }\n}\n```\n\n2. Create RolePermission entity class:\n```csharp\npublic class RolePermission\n{\n    public int Id { get; set; }\n    public int RoleId { get; set; }\n    public string Permission { get; set; }\n    \n    // Navigation property\n    public virtual Role Role { get; set; }\n}\n```\n\n3. Configure entities in DbContext:\n```csharp\npublic class ApplicationDbContext : DbContext\n{\n    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)\n        : base(options)\n    { }\n    \n    public DbSet<Role> Roles { get; set; }\n    public DbSet<RolePermission> RolePermissions { get; set; }\n    \n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        base.OnModelCreating(modelBuilder);\n        \n        modelBuilder.Entity<Role>(entity =>\n        {\n            entity.ToTable(\"ROLE\");\n            entity.HasKey(e => e.Id);\n            entity.Property(e => e.Name).IsRequired().HasMaxLength(50);\n            entity.Property(e => e.DisplayName).IsRequired().HasMaxLength(100);\n            entity.Property(e => e.Description).HasMaxLength(500);\n            entity.Property(e => e.IsSystemRole).HasDefaultValue(false);\n        });\n        \n        modelBuilder.Entity<RolePermission>(entity =>\n        {\n            entity.ToTable(\"ROLE_PERMISSION\");\n            entity.HasKey(e => e.Id);\n            entity.Property(e => e.Permission).IsRequired().HasMaxLength(100);\n            \n            entity.HasOne(d => d.Role)\n                  .WithMany(p => p.RolePermissions)\n                  .HasForeignKey(d => d.RoleId);\n        });\n    }\n}\n```",
      "testStrategy": "1. Verify entity models map correctly to database tables\n2. Test navigation properties work as expected\n3. Validate constraints and relationships\n4. Create unit tests for CRUD operations using in-memory database\n5. Ensure proper mapping between C# properties and database columns",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Backend MSAL Authentication",
      "description": "Integrate Microsoft Identity Web for MSAL authentication in the ASP.NET Core backend, including JWT Bearer authentication for token validation.",
      "details": "1. Install required NuGet packages:\n   - Microsoft.Identity.Web\n   - Microsoft.Identity.Web.UI\n   - Microsoft.AspNetCore.Authentication.JwtBearer\n\n2. Configure services in Startup.cs:\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n            .AddMicrosoftIdentityWebApi(Configuration.GetSection(\"AzureAd\"));\n            \n    // Configure accepted token audience\n    services.Configure<JwtBearerOptions>(JwtBearerDefaults.AuthenticationScheme, options =>\n    {\n        options.TokenValidationParameters.ValidAudiences = new[]\n        {\n            $\"api://{Configuration[\"AzureAd:ClientId\"]}\"\n        };\n    });\n    \n    // Other service configurations...\n}\n\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    // Other middleware...\n    \n    app.UseAuthentication();\n    app.UseAuthorization();\n    \n    // Other middleware...\n}\n```\n\n3. Create a base API controller with authentication:\n```csharp\n[ApiController]\n[Authorize]\n[Route(\"api/[controller]\")]\npublic abstract class AuthenticatedControllerBase : ControllerBase\n{\n    protected string GetUserObjectId()\n    {\n        return User.FindFirst(\"http://schemas.microsoft.com/identity/claims/objectidentifier\")?.Value;\n    }\n    \n    protected string GetUserEmail()\n    {\n        return User.FindFirst(\"preferred_username\")?.Value;\n    }\n}\n```",
      "testStrategy": "1. Test authentication with valid Azure AD tokens\n2. Verify token validation with invalid tokens fails appropriately\n3. Test token audience validation\n4. Verify claims are correctly extracted from tokens\n5. Test authentication middleware in the request pipeline\n6. Ensure unauthenticated requests to protected endpoints are rejected",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Install and Configure Required NuGet Packages",
          "description": "Add the necessary NuGet packages for MSAL.NET and Microsoft Identity integration to the backend project. Ensure the correct versions are installed and reference official documentation for compatibility.",
          "dependencies": [],
          "details": "Install packages such as Microsoft.Identity.Client and Microsoft.Identity.Web using NuGet Package Manager or CLI. Verify installation and resolve any dependency issues.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Set Up Authentication Services and Middleware in Startup.cs",
          "description": "Configure authentication services and middleware in the Startup.cs file to enable MSAL-based authentication for the backend application.",
          "dependencies": [
            1
          ],
          "details": "In the ConfigureServices method, add authentication services using Microsoft Identity. In the Configure method, add authentication and authorization middleware to the request pipeline.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Token Validation and Audience Configuration",
          "description": "Configure token validation parameters and specify the expected audience to ensure only valid tokens are accepted by the backend.",
          "dependencies": [
            2
          ],
          "details": "Set up token validation options, including issuer, audience, and signing keys. Ensure the backend only accepts tokens issued for the correct audience and validates claims as required.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Base Authenticated Controller with User Claim Extraction Methods",
          "description": "Develop a base controller class that enforces authentication and provides utility methods for extracting user claims from the authenticated context.",
          "dependencies": [
            3
          ],
          "details": "Implement a controller base class that checks for authentication and exposes methods to retrieve user claims (e.g., user ID, roles, email) from the JWT token.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 4,
      "title": "Implement Permission-Based Authorization System",
      "description": "Create a custom authorization system that validates user permissions based on their roles, with support for system roles that bypass permission checks.",
      "details": "1. Create a Permission class to define static permissions:\n```csharp\npublic static class Permissions\n{\n    // Projects\n    public const string ViewProjects = \"Projects.View\";\n    public const string EditProjects = \"Projects.Edit\";\n    \n    // Deliverables\n    public const string ViewDeliverables = \"Deliverables.View\";\n    public const string EditDeliverables = \"Deliverables.Edit\";\n    \n    // Add other permissions as needed\n    \n    public static IEnumerable<string> GetAllPermissions()\n    {\n        return typeof(Permissions)\n            .GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy)\n            .Where(fi => fi.IsLiteral && !fi.IsInitOnly && fi.FieldType == typeof(string))\n            .Select(x => (string)x.GetRawConstantValue())\n            .ToList();\n    }\n    \n    public static IEnumerable<(string Permission, string Category)> GetPermissionsWithCategories()\n    {\n        return GetAllPermissions()\n            .Select(p => {\n                var parts = p.Split('.');\n                return (Permission: p, Category: parts[0]);\n            });\n    }\n}\n```\n\n2. Create a RequirePermission attribute:\n```csharp\n[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]\npublic class RequirePermissionAttribute : AuthorizeAttribute\n{\n    public RequirePermissionAttribute(string permission) : base(policy: permission)\n    {\n    }\n}\n```\n\n3. Implement authorization handler:\n```csharp\npublic class PermissionAuthorizationHandler : AuthorizationHandler<PermissionRequirement>\n{\n    private readonly ApplicationDbContext _dbContext;\n    private readonly IConfiguration _configuration;\n    \n    public PermissionAuthorizationHandler(ApplicationDbContext dbContext, IConfiguration configuration)\n    {\n        _dbContext = dbContext;\n        _configuration = configuration;\n    }\n    \n    protected override async Task HandleRequirementAsync(\n        AuthorizationHandlerContext context,\n        PermissionRequirement requirement)\n    {\n        if (!context.User.Identity.IsAuthenticated)\n        {\n            return;\n        }\n        \n        var userEmail = context.User.FindFirst(\"preferred_username\")?.Value;\n        if (string.IsNullOrEmpty(userEmail))\n        {\n            return;\n        }\n        \n        // Get user roles from claims\n        var userRoles = context.User.FindAll(ClaimTypes.Role).Select(c => c.Value).ToList();\n        \n        // Check if user has any system role\n        var systemRoles = await _dbContext.Roles\n            .Where(r => r.IsSystemRole && userRoles.Contains(r.Name.ToLower()))\n            .AnyAsync();\n            \n        // Development flag for system roles\n        bool isDevelopment = _configuration.GetValue<bool>(\"DevelopmentMode\", false);\n        if (isDevelopment && userEmail.EndsWith(\"@yourdomain.com\"))\n        {\n            systemRoles = true;\n        }\n        \n        if (systemRoles)\n        {\n            context.Succeed(requirement);\n            return;\n        }\n        \n        // Check specific permission\n        var hasPermission = await _dbContext.Roles\n            .Where(r => userRoles.Contains(r.Name.ToLower()))\n            .SelectMany(r => r.RolePermissions)\n            .AnyAsync(rp => rp.Permission.Equals(requirement.Permission, StringComparison.OrdinalIgnoreCase));\n            \n        if (hasPermission)\n        {\n            context.Succeed(requirement);\n        }\n    }\n}\n\npublic class PermissionRequirement : IAuthorizationRequirement\n{\n    public string Permission { get; }\n    \n    public PermissionRequirement(string permission)\n    {\n        Permission = permission;\n    }\n}\n```\n\n4. Register authorization services:\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    // Other service configurations...\n    \n    services.AddScoped<IAuthorizationHandler, PermissionAuthorizationHandler>();\n    \n    services.AddAuthorization(options =>\n    {\n        // Register each permission as a policy\n        foreach (var permission in Permissions.GetAllPermissions())\n        {\n            options.AddPolicy(permission, policy =>\n                policy.Requirements.Add(new PermissionRequirement(permission)));\n        }\n    });\n}\n```",
      "testStrategy": "1. Test authorization with users having specific permissions\n2. Verify system role users bypass permission checks\n3. Test case-insensitive role mapping\n4. Verify development flag works correctly\n5. Test authorization fails for users without required permissions\n6. Verify automatic view permission when edit permission is granted\n7. Test with various combinations of roles and permissions",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create the Permissions class",
          "description": "Define a static Permissions class with constants for all application permissions and helper methods for permission management",
          "dependencies": [],
          "details": "Create a static class that contains string constants for all permissions (e.g., 'Products.View', 'Products.Create'). Implement helper methods to group permissions by module, get all permissions, and check permission inheritance relationships. Include documentation for each permission constant.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement the RequirePermission attribute",
          "description": "Create a custom authorization attribute that can be applied to controllers and actions",
          "dependencies": [
            1
          ],
          "details": "Develop a RequirePermission attribute that inherits from AuthorizeAttribute. The attribute should accept one or more permission strings as parameters and register the appropriate authorization policy. Ensure it works at both controller and action levels with proper permission inheritance.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create the PermissionRequirement class",
          "description": "Implement the IAuthorizationRequirement interface for permission-based requirements",
          "dependencies": [
            1
          ],
          "details": "Create a PermissionRequirement class that implements IAuthorizationRequirement. This class should store the permission string required for authorization and provide methods to check if a user has the specific permission or any permission that inherits from it.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement the PermissionAuthorizationHandler",
          "description": "Create a handler that evaluates permission requirements against user claims with system role bypass logic",
          "dependencies": [
            3
          ],
          "details": "Develop a PermissionAuthorizationHandler that inherits from AuthorizationHandler<PermissionRequirement>. Implement the HandleRequirementAsync method to check if the user has the required permission claim or a system role that bypasses permission checks. Include logic to handle permission inheritance.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Register authorization services and policies",
          "description": "Configure the application's service collection with the custom authorization components",
          "dependencies": [
            2,
            4
          ],
          "details": "Add extension methods for IServiceCollection to register the authorization services, handlers, and policies. Configure the application to use the custom permission-based authorization system. Set up policy providers to dynamically create policies based on permission requirements.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Test the authorization system",
          "description": "Create test scenarios to verify the permission-based authorization system works correctly",
          "dependencies": [
            5
          ],
          "details": "Develop test cases for different permission scenarios including: basic permission checks, permission inheritance, system role bypasses, and denied access cases. Create test controllers and actions with various permission requirements. Verify that users with appropriate permissions or system roles can access protected resources while others are denied.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 5,
      "title": "Implement Frontend MSAL Authentication",
      "description": "Integrate MSAL authentication in the React frontend using @azure/msal-browser and @azure/msal-react libraries.",
      "details": "1. Install required npm packages:\n```bash\nnpm install @azure/msal-browser @azure/msal-react\n```\n\n2. Create MSAL configuration:\n```typescript\n// src/auth/msalConfig.ts\nimport { Configuration, LogLevel } from '@azure/msal-browser';\n\nexport const msalConfig: Configuration = {\n  auth: {\n    clientId: 'c67bf91d-8b6a-494a-8b99-c7a4592e08c1',\n    authority: 'https://login.microsoftonline.com/3c7fa9e9-64e7-443c-905a-d9134ca00da9',\n    redirectUri: window.location.origin,\n    postLogoutRedirectUri: window.location.origin,\n  },\n  cache: {\n    cacheLocation: 'sessionStorage',\n    storeAuthStateInCookie: false,\n  },\n  system: {\n    loggerOptions: {\n      loggerCallback: (level, message, containsPii) => {\n        if (containsPii) {\n          return;\n        }\n        switch (level) {\n          case LogLevel.Error:\n            console.error(message);\n            return;\n          case LogLevel.Info:\n            console.info(message);\n            return;\n          case LogLevel.Verbose:\n            console.debug(message);\n            return;\n          case LogLevel.Warning:\n            console.warn(message);\n            return;\n        }\n      },\n      logLevel: LogLevel.Warning\n    }\n  }\n};\n\nexport const loginRequest = {\n  scopes: [\n    'api://c67bf91d-8b6a-494a-8b99-c7a4592e08c1/Application.User',\n    'api://c67bf91d-8b6a-494a-8b99-c7a4592e08c1/Application.Admin'\n  ]\n};\n```\n\n3. Set up MSAL Provider in the application:\n```typescript\n// src/index.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { PublicClientApplication } from '@azure/msal-browser';\nimport { MsalProvider } from '@azure/msal-react';\nimport { msalConfig } from './auth/msalConfig';\nimport App from './App';\n\nconst msalInstance = new PublicClientApplication(msalConfig);\n\nReactDOM.render(\n  <React.StrictMode>\n    <MsalProvider instance={msalInstance}>\n      <App />\n    </MsalProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\n4. Create authentication context:\n```typescript\n// src/auth/AuthContext.tsx\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { useMsal, useAccount } from '@azure/msal-react';\nimport { loginRequest } from './msalConfig';\n\ninterface AuthContextType {\n  isAuthenticated: boolean;\n  login: () => void;\n  logout: () => void;\n  getToken: () => Promise<string | null>;\n  userRoles: string[];\n}\n\nconst AuthContext = createContext<AuthContextType>(null!);\n\nexport const AuthProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {\n  const { instance, accounts, inProgress } = useMsal();\n  const account = useAccount(accounts[0] || {});\n  const [userRoles, setUserRoles] = useState<string[]>([]);\n  \n  useEffect(() => {\n    if (account && account.idTokenClaims) {\n      // Extract roles from token claims\n      const roles = account.idTokenClaims.roles || [];\n      setUserRoles(roles);\n    }\n  }, [account]);\n  \n  const login = async () => {\n    try {\n      await instance.loginPopup(loginRequest);\n    } catch (error) {\n      console.error('Login failed', error);\n    }\n  };\n  \n  const logout = () => {\n    instance.logout();\n  };\n  \n  const getToken = async (): Promise<string | null> => {\n    if (!account) return null;\n    \n    try {\n      const response = await instance.acquireTokenSilent({\n        ...loginRequest,\n        account: account\n      });\n      return response.accessToken;\n    } catch (error) {\n      console.error('Token acquisition failed', error);\n      return null;\n    }\n  };\n  \n  const value = {\n    isAuthenticated: !!account,\n    login,\n    logout,\n    getToken,\n    userRoles\n  };\n  \n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n```\n\n5. Create protected route component:\n```typescript\n// src/auth/ProtectedRoute.tsx\nimport React from 'react';\nimport { Route, Redirect, RouteProps } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\ninterface ProtectedRouteProps extends RouteProps {\n  requiredPermission?: string;\n}\n\nexport const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ \n  requiredPermission,\n  ...routeProps \n}) => {\n  const { isAuthenticated, userRoles } = useAuth();\n  \n  if (!isAuthenticated) {\n    return <Redirect to=\"/login\" />;\n  }\n  \n  // If no specific permission is required, just check authentication\n  if (!requiredPermission) {\n    return <Route {...routeProps} />;\n  }\n  \n  // For permission-based access, we'll implement this in the next task\n  // For now, just allow access if authenticated\n  \n  return <Route {...routeProps} />;\n};\n```",
      "testStrategy": "1. Test login functionality with valid Azure AD credentials\n2. Verify token acquisition and storage\n3. Test silent authentication for returning users\n4. Verify logout functionality properly clears tokens\n5. Test protected routes redirect unauthenticated users\n6. Verify role extraction from token claims\n7. Test error handling during authentication failures",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up MSAL configuration",
          "description": "Configure MSAL with proper client ID, authority, and scopes for authentication",
          "dependencies": [],
          "details": "Create an authConfig.js file that defines the MSAL configuration parameters including clientId, authority, redirectUri, and necessary API scopes. Reference Microsoft's sample code for the correct structure and required parameters. This configuration will be the foundation for all authentication operations.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement AuthProvider context",
          "description": "Create a React context provider with login/logout functionality using MSAL",
          "dependencies": [
            1
          ],
          "details": "Develop an AuthProvider component that initializes the MSAL instance using the configuration from subtask 1. Implement login, logout, and token acquisition methods. Manage authentication state (isAuthenticated, user data, etc.) and provide it through context. Handle token caching and silent token renewal.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create useAuth custom hook",
          "description": "Develop a custom React hook for accessing authentication state and methods",
          "dependencies": [
            2
          ],
          "details": "Create a useAuth hook that consumes the AuthProvider context and exposes authentication state and methods in a clean, reusable way. Include functions to check authentication status, get user information, acquire tokens, and handle login/logout. Ensure proper error handling and loading states are included.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement ProtectedRoute component",
          "description": "Create a component to protect routes based on authentication status",
          "dependencies": [
            3
          ],
          "details": "Develop a ProtectedRoute component that uses the useAuth hook to check authentication status. Implement logic to redirect unauthenticated users to the login page. Add support for role-based access control if needed. Ensure the component properly handles loading states during authentication checks.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement API Authentication Interceptor",
      "description": "Create an API client with authentication interceptor to automatically include MSAL tokens in API requests.",
      "details": "1. Create an authenticated API client using Axios:\n```typescript\n// src/api/apiClient.ts\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\n\nlet authTokenProvider: () => Promise<string | null> = async () => null;\n\nexport const setAuthTokenProvider = (provider: () => Promise<string | null>) => {\n  authTokenProvider = provider;\n};\n\nconst apiClient: AxiosInstance = axios.create({\n  baseURL: '/api',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\napiClient.interceptors.request.use(\n  async (config: AxiosRequestConfig) => {\n    const token = await authTokenProvider();\n    if (token) {\n      config.headers = {\n        ...config.headers,\n        Authorization: `Bearer ${token}`\n      };\n    }\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Handle 401 responses\napiClient.interceptors.response.use(\n  (response: AxiosResponse) => response,\n  (error) => {\n    if (error.response && error.response.status === 401) {\n      // Redirect to login page or trigger re-authentication\n      window.location.href = '/login';\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default apiClient;\n```\n\n2. Initialize the API client with the auth token provider in the App component:\n```typescript\n// src/App.tsx\nimport React, { useEffect } from 'react';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport { AuthProvider, useAuth } from './auth/AuthContext';\nimport { setAuthTokenProvider } from './api/apiClient';\nimport Routes from './Routes';\n\nconst AppContent: React.FC = () => {\n  const { getToken } = useAuth();\n  \n  useEffect(() => {\n    setAuthTokenProvider(getToken);\n  }, [getToken]);\n  \n  return (\n    <Router>\n      <Routes />\n    </Router>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <AuthProvider>\n      <AppContent />\n    </AuthProvider>\n  );\n};\n\nexport default App;\n```\n\n3. Create API service modules using the authenticated client:\n```typescript\n// src/api/roleService.ts\nimport apiClient from './apiClient';\nimport { Role, RolePermission } from '../types';\n\nexport const getRoles = async (): Promise<Role[]> => {\n  const response = await apiClient.get('/roles');\n  return response.data;\n};\n\nexport const getRole = async (id: number): Promise<Role> => {\n  const response = await apiClient.get(`/roles/${id}`);\n  return response.data;\n};\n\nexport const createRole = async (role: Omit<Role, 'id'>): Promise<Role> => {\n  const response = await apiClient.post('/roles', role);\n  return response.data;\n};\n\nexport const updateRole = async (id: number, role: Partial<Role>): Promise<Role> => {\n  const response = await apiClient.put(`/roles/${id}`, role);\n  return response.data;\n};\n\nexport const deleteRole = async (id: number): Promise<void> => {\n  await apiClient.delete(`/roles/${id}`);\n};\n\nexport const getRolePermissions = async (roleId: number): Promise<RolePermission[]> => {\n  const response = await apiClient.get(`/roles/${roleId}/permissions`);\n  return response.data;\n};\n\nexport const updateRolePermissions = async (\n  roleId: number, \n  permissions: string[]\n): Promise<void> => {\n  await apiClient.put(`/roles/${roleId}/permissions`, { permissions });\n};\n```",
      "testStrategy": "1. Test API requests include authentication token\n2. Verify token refresh is handled correctly\n3. Test error handling for 401 responses\n4. Verify API client correctly handles various HTTP methods\n5. Test API service functions with mock responses\n6. Verify authentication token provider is correctly initialized",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Role Management API Endpoints",
      "description": "Create backend API endpoints for managing roles, including CRUD operations for roles.",
      "details": "1. Create a RoleController:\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\n[Authorize]\npublic class RolesController : ControllerBase\n{\n    private readonly ApplicationDbContext _context;\n    \n    public RolesController(ApplicationDbContext context)\n    {\n        _context = context;\n    }\n    \n    [HttpGet]\n    [RequirePermission(Permissions.ViewRoles)]\n    public async Task<ActionResult<IEnumerable<RoleDto>>> GetRoles()\n    {\n        var roles = await _context.Roles\n            .Select(r => new RoleDto\n            {\n                Id = r.Id,\n                Name = r.Name,\n                DisplayName = r.DisplayName,\n                Description = r.Description,\n                IsSystemRole = r.IsSystemRole\n            })\n            .ToListAsync();\n            \n        return Ok(roles);\n    }\n    \n    [HttpGet(\"{id}\")]\n    [RequirePermission(Permissions.ViewRoles)]\n    public async Task<ActionResult<RoleDto>> GetRole(int id)\n    {\n        var role = await _context.Roles.FindAsync(id);\n        \n        if (role == null)\n        {\n            return NotFound();\n        }\n        \n        var roleDto = new RoleDto\n        {\n            Id = role.Id,\n            Name = role.Name,\n            DisplayName = role.DisplayName,\n            Description = role.Description,\n            IsSystemRole = role.IsSystemRole\n        };\n        \n        return Ok(roleDto);\n    }\n    \n    [HttpPost]\n    [RequirePermission(Permissions.EditRoles)]\n    public async Task<ActionResult<RoleDto>> CreateRole(CreateRoleDto createRoleDto)\n    {\n        // Check if role with same name already exists\n        if (await _context.Roles.AnyAsync(r => r.Name == createRoleDto.Name))\n        {\n            return BadRequest(new { message = \"Role with this name already exists\" });\n        }\n        \n        var role = new Role\n        {\n            Name = createRoleDto.Name,\n            DisplayName = createRoleDto.DisplayName,\n            Description = createRoleDto.Description,\n            IsSystemRole = createRoleDto.IsSystemRole\n        };\n        \n        _context.Roles.Add(role);\n        await _context.SaveChangesAsync();\n        \n        var roleDto = new RoleDto\n        {\n            Id = role.Id,\n            Name = role.Name,\n            DisplayName = role.DisplayName,\n            Description = role.Description,\n            IsSystemRole = role.IsSystemRole\n        };\n        \n        return CreatedAtAction(nameof(GetRole), new { id = role.Id }, roleDto);\n    }\n    \n    [HttpPut(\"{id}\")]\n    [RequirePermission(Permissions.EditRoles)]\n    public async Task<IActionResult> UpdateRole(int id, UpdateRoleDto updateRoleDto)\n    {\n        var role = await _context.Roles.FindAsync(id);\n        \n        if (role == null)\n        {\n            return NotFound();\n        }\n        \n        // Name cannot be changed after creation\n        role.DisplayName = updateRoleDto.DisplayName;\n        role.Description = updateRoleDto.Description;\n        role.IsSystemRole = updateRoleDto.IsSystemRole;\n        \n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateConcurrencyException)\n        {\n            if (!await RoleExists(id))\n            {\n                return NotFound();\n            }\n            else\n            {\n                throw;\n            }\n        }\n        \n        return NoContent();\n    }\n    \n    [HttpDelete(\"{id}\")]\n    [RequirePermission(Permissions.EditRoles)]\n    public async Task<IActionResult> DeleteRole(int id)\n    {\n        var role = await _context.Roles.FindAsync(id);\n        \n        if (role == null)\n        {\n            return NotFound();\n        }\n        \n        _context.Roles.Remove(role);\n        await _context.SaveChangesAsync();\n        \n        return NoContent();\n    }\n    \n    private async Task<bool> RoleExists(int id)\n    {\n        return await _context.Roles.AnyAsync(e => e.Id == id);\n    }\n}\n```\n\n2. Create DTOs for role operations:\n```csharp\npublic class RoleDto\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string DisplayName { get; set; }\n    public string Description { get; set; }\n    public bool IsSystemRole { get; set; }\n}\n\npublic class CreateRoleDto\n{\n    [Required]\n    [StringLength(50)]\n    public string Name { get; set; }\n    \n    [Required]\n    [StringLength(100)]\n    public string DisplayName { get; set; }\n    \n    [StringLength(500)]\n    public string Description { get; set; }\n    \n    public bool IsSystemRole { get; set; }\n}\n\npublic class UpdateRoleDto\n{\n    [Required]\n    [StringLength(100)]\n    public string DisplayName { get; set; }\n    \n    [StringLength(500)]\n    public string Description { get; set; }\n    \n    public bool IsSystemRole { get; set; }\n}\n```",
      "testStrategy": "1. Test CRUD operations for roles\n2. Verify authorization requirements are enforced\n3. Test validation of role data\n4. Verify role name uniqueness constraint\n5. Test error handling for not found and concurrency issues\n6. Verify system role flag is correctly persisted\n7. Test that role name cannot be changed after creation",
      "priority": "medium",
      "dependencies": [
        2,
        3,
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Permission Management API Endpoints",
      "description": "Create backend API endpoints for managing permissions, including retrieving available permissions and updating role permissions.",
      "details": "1. Add permission endpoints to RolesController:\n```csharp\n[HttpGet(\"permissions\")]\n[RequirePermission(Permissions.ViewRoles)]\npublic ActionResult<IEnumerable<PermissionDto>> GetAllPermissions()\n{\n    var permissions = Permissions.GetPermissionsWithCategories()\n        .Select(p => new PermissionDto\n        {\n            Name = p.Permission,\n            Category = p.Category\n        })\n        .ToList();\n        \n    return Ok(permissions);\n}\n\n[HttpGet(\"{id}/permissions\")]\n[RequirePermission(Permissions.ViewRoles)]\npublic async Task<ActionResult<RolePermissionsDto>> GetRolePermissions(int id)\n{\n    var role = await _context.Roles\n        .Include(r => r.RolePermissions)\n        .FirstOrDefaultAsync(r => r.Id == id);\n        \n    if (role == null)\n    {\n        return NotFound();\n    }\n    \n    var allPermissions = Permissions.GetAllPermissions().ToList();\n    var rolePermissions = role.RolePermissions.Select(rp => rp.Permission).ToList();\n    \n    var permissionDtos = allPermissions\n        .Select(p => new PermissionDto\n        {\n            Name = p,\n            Category = p.Split('.')[0],\n            IsGranted = rolePermissions.Contains(p) || role.IsSystemRole\n        })\n        .ToList();\n        \n    var result = new RolePermissionsDto\n    {\n        RoleId = role.Id,\n        RoleName = role.Name,\n        IsSystemRole = role.IsSystemRole,\n        Permissions = permissionDtos\n    };\n    \n    return Ok(result);\n}\n\n[HttpPut(\"{id}/permissions\")]\n[RequirePermission(Permissions.EditRoles)]\npublic async Task<IActionResult> UpdateRolePermissions(int id, UpdateRolePermissionsDto updateDto)\n{\n    var role = await _context.Roles\n        .Include(r => r.RolePermissions)\n        .FirstOrDefaultAsync(r => r.Id == id);\n        \n    if (role == null)\n    {\n        return NotFound();\n    }\n    \n    // If it's a system role, we don't need to update permissions\n    // as system roles automatically have all permissions\n    if (role.IsSystemRole)\n    {\n        return NoContent();\n    }\n    \n    // Validate permissions\n    var allPermissions = Permissions.GetAllPermissions().ToList();\n    var invalidPermissions = updateDto.Permissions\n        .Where(p => !allPermissions.Contains(p))\n        .ToList();\n        \n    if (invalidPermissions.Any())\n    {\n        return BadRequest(new { message = \"Invalid permissions\", permissions = invalidPermissions });\n    }\n    \n    // Auto-grant view permissions when edit permissions are granted\n    var permissionsToGrant = new HashSet<string>(updateDto.Permissions);\n    foreach (var permission in updateDto.Permissions.Where(p => p.EndsWith(\".Edit\")))\n    {\n        var viewPermission = permission.Replace(\".Edit\", \".View\");\n        if (allPermissions.Contains(viewPermission))\n        {\n            permissionsToGrant.Add(viewPermission);\n        }\n    }\n    \n    // Remove existing permissions\n    _context.RolePermissions.RemoveRange(role.RolePermissions);\n    \n    // Add new permissions\n    foreach (var permission in permissionsToGrant)\n    {\n        role.RolePermissions.Add(new RolePermission\n        {\n            RoleId = role.Id,\n            Permission = permission\n        });\n    }\n    \n    await _context.SaveChangesAsync();\n    \n    return NoContent();\n}\n```\n\n2. Create DTOs for permission operations:\n```csharp\npublic class PermissionDto\n{\n    public string Name { get; set; }\n    public string Category { get; set; }\n    public bool IsGranted { get; set; }\n}\n\npublic class RolePermissionsDto\n{\n    public int RoleId { get; set; }\n    public string RoleName { get; set; }\n    public bool IsSystemRole { get; set; }\n    public List<PermissionDto> Permissions { get; set; }\n}\n\npublic class UpdateRolePermissionsDto\n{\n    [Required]\n    public List<string> Permissions { get; set; }\n}\n```",
      "testStrategy": "1. Test retrieving all available permissions\n2. Verify permissions are correctly grouped by category\n3. Test retrieving permissions for a specific role\n4. Verify system roles show all permissions as granted\n5. Test updating role permissions\n6. Verify view permissions are automatically granted when edit permissions are assigned\n7. Test validation of permission names\n8. Verify authorization requirements are enforced",
      "priority": "medium",
      "dependencies": [
        2,
        3,
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Role Management UI",
      "description": "Create a grid-based interface for managing roles, including creation, editing, and deletion of roles.",
      "details": "1. Create Role management page:\n```tsx\n// src/pages/RoleManagement.tsx\nimport React, { useEffect, useState } from 'react';\nimport { DataGrid, Column, Editing, Popup, Form, Button } from 'devextreme-react/data-grid';\nimport { Item } from 'devextreme-react/form';\nimport { confirm } from 'devextreme/ui/dialog';\nimport { useHistory } from 'react-router-dom';\nimport { getRoles, createRole, updateRole, deleteRole } from '../api/roleService';\nimport { Role } from '../types';\nimport { useAuth } from '../auth/AuthContext';\nimport { toast } from 'react-toastify';\n\nconst RoleManagement: React.FC = () => {\n  const [roles, setRoles] = useState<Role[]>([]);\n  const [loading, setLoading] = useState(true);\n  const history = useHistory();\n  const { userRoles } = useAuth();\n  \n  // Check if user has permission to edit roles\n  const canEditRoles = userRoles.includes('Application.Admin');\n  \n  useEffect(() => {\n    loadRoles();\n  }, []);\n  \n  const loadRoles = async () => {\n    try {\n      setLoading(true);\n      const data = await getRoles();\n      setRoles(data);\n    } catch (error) {\n      toast.error('Failed to load roles');\n      console.error(error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const handleRoleCreated = async (e: any) => {\n    try {\n      const role = e.data;\n      await createRole(role);\n      toast.success('Role created successfully');\n      await loadRoles();\n    } catch (error) {\n      toast.error('Failed to create role');\n      console.error(error);\n      e.cancel = true;\n    }\n  };\n  \n  const handleRoleUpdated = async (e: any) => {\n    try {\n      const role = e.data;\n      await updateRole(role.id, role);\n      toast.success('Role updated successfully');\n      await loadRoles();\n    } catch (error) {\n      toast.error('Failed to update role');\n      console.error(error);\n      e.cancel = true;\n    }\n  };\n  \n  const handleRoleDeleted = async (e: any) => {\n    try {\n      const result = await confirm('Are you sure you want to delete this role?', 'Confirm deletion');\n      if (result) {\n        await deleteRole(e.data.id);\n        toast.success('Role deleted successfully');\n        await loadRoles();\n      } else {\n        e.cancel = true;\n      }\n    } catch (error) {\n      toast.error('Failed to delete role');\n      console.error(error);\n      e.cancel = true;\n    }\n  };\n  \n  const navigateToPermissions = (e: any) => {\n    const roleId = e.row.data.id;\n    history.push(`/roles/${roleId}/permissions`);\n  };\n  \n  return (\n    <div className=\"content-block\">\n      <h2>Role Management</h2>\n      \n      <DataGrid\n        dataSource={roles}\n        keyExpr=\"id\"\n        showBorders={true}\n        loadPanel={{ enabled: loading }}\n        onRowInserted={handleRoleCreated}\n        onRowUpdated={handleRoleUpdated}\n        onRowRemoved={handleRoleDeleted}\n      >\n        <Editing\n          mode=\"popup\"\n          allowAdding={canEditRoles}\n          allowUpdating={canEditRoles}\n          allowDeleting={canEditRoles}\n          useIcons={true}\n        >\n          <Popup title=\"Role Details\" showTitle={true} width={700} height={525} />\n          <Form>\n            <Item dataField=\"name\" editorOptions={{ disabled: e => e.row?.data?.id > 0 }} />\n            <Item dataField=\"displayName\" />\n            <Item dataField=\"description\" editorType=\"dxTextArea\" editorOptions={{ height: 100 }} />\n            <Item dataField=\"isSystemRole\" editorType=\"dxCheckBox\" />\n          </Form>\n        </Editing>\n        \n        <Column dataField=\"name\" caption=\"Name\" />\n        <Column dataField=\"displayName\" caption=\"Display Name\" />\n        <Column dataField=\"description\" caption=\"Description\" />\n        <Column dataField=\"isSystemRole\" caption=\"System Role\" dataType=\"boolean\" />\n        <Column type=\"buttons\">\n          <Button name=\"edit\" />\n          <Button name=\"delete\" />\n          <Button\n            hint=\"Manage Permissions\"\n            icon=\"key\"\n            visible={true}\n            onClick={navigateToPermissions}\n          />\n        </Column>\n      </DataGrid>\n    </div>\n  );\n};\n\nexport default RoleManagement;\n```\n\n2. Add types for roles:\n```typescript\n// src/types/index.ts\nexport interface Role {\n  id: number;\n  name: string;\n  displayName: string;\n  description: string;\n  isSystemRole: boolean;\n}\n\nexport interface Permission {\n  name: string;\n  category: string;\n  isGranted: boolean;\n}\n\nexport interface RolePermissions {\n  roleId: number;\n  roleName: string;\n  isSystemRole: boolean;\n  permissions: Permission[];\n}\n```\n\n3. Add the role management page to routes:\n```typescript\n// src/Routes.tsx\nimport React from 'react';\nimport { Switch, Route, Redirect } from 'react-router-dom';\nimport { ProtectedRoute } from './auth/ProtectedRoute';\nimport LoginPage from './pages/LoginPage';\nimport HomePage from './pages/HomePage';\nimport RoleManagement from './pages/RoleManagement';\nimport PermissionManagement from './pages/PermissionManagement';\n\nconst Routes: React.FC = () => {\n  return (\n    <Switch>\n      <Route path=\"/login\" component={LoginPage} />\n      <ProtectedRoute exact path=\"/\" component={HomePage} />\n      <ProtectedRoute \n        path=\"/roles\" \n        exact \n        component={RoleManagement} \n        requiredPermission=\"Roles.View\" \n      />\n      <ProtectedRoute \n        path=\"/roles/:id/permissions\" \n        component={PermissionManagement} \n        requiredPermission=\"Roles.Edit\" \n      />\n      <Redirect to=\"/\" />\n    </Switch>\n  );\n};\n\nexport default Routes;\n```",
      "testStrategy": "1. Test role listing functionality\n2. Verify role creation with validation\n3. Test role editing, ensuring name cannot be changed\n4. Verify role deletion with confirmation\n5. Test navigation to permission management\n6. Verify system role flag can be set/unset\n7. Test authorization controls for edit operations\n8. Verify error handling and notifications",
      "priority": "medium",
      "dependencies": [
        5,
        6,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Permission Management UI",
      "description": "Create a UI for managing permissions assigned to roles, with permissions grouped by category and support for system roles.",
      "details": "1. Create Permission management page:\n```tsx\n// src/pages/PermissionManagement.tsx\nimport React, { useEffect, useState } from 'react';\nimport { useParams, useHistory } from 'react-router-dom';\nimport { Button } from 'devextreme-react/button';\nimport { CheckBox } from 'devextreme-react/check-box';\nimport { getRolePermissions, updateRolePermissions } from '../api/roleService';\nimport { Permission, RolePermissions } from '../types';\nimport { toast } from 'react-toastify';\n\ninterface PermissionGrouped {\n  category: string;\n  permissions: Permission[];\n}\n\nconst PermissionManagement: React.FC = () => {\n  const { id } = useParams<{ id: string }>();\n  const history = useHistory();\n  const [rolePermissions, setRolePermissions] = useState<RolePermissions | null>(null);\n  const [groupedPermissions, setGroupedPermissions] = useState<PermissionGrouped[]>([]);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    loadPermissions();\n  }, [id]);\n  \n  const loadPermissions = async () => {\n    try {\n      setLoading(true);\n      const data = await getRolePermissions(parseInt(id));\n      setRolePermissions(data);\n      \n      // Group permissions by category\n      const grouped = data.permissions.reduce((groups: PermissionGrouped[], permission) => {\n        const category = permission.category;\n        const group = groups.find(g => g.category === category);\n        \n        if (group) {\n          group.permissions.push(permission);\n        } else {\n          groups.push({\n            category,\n            permissions: [permission]\n          });\n        }\n        \n        return groups;\n      }, []);\n      \n      setGroupedPermissions(grouped);\n    } catch (error) {\n      toast.error('Failed to load permissions');\n      console.error(error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const handlePermissionChange = (permission: Permission, value: boolean) => {\n    if (!rolePermissions) return;\n    \n    const updatedPermissions = rolePermissions.permissions.map(p => {\n      if (p.name === permission.name) {\n        return { ...p, isGranted: value };\n      }\n      \n      // If granting an edit permission, automatically grant the corresponding view permission\n      if (value && permission.name.endsWith('.Edit') && \n          p.name === permission.name.replace('.Edit', '.View')) {\n        return { ...p, isGranted: true };\n      }\n      \n      return p;\n    });\n    \n    setRolePermissions({\n      ...rolePermissions,\n      permissions: updatedPermissions\n    });\n    \n    // Update grouped permissions\n    const updatedGroups = groupedPermissions.map(group => ({\n      ...group,\n      permissions: group.permissions.map(p => {\n        const updatedPerm = updatedPermissions.find(up => up.name === p.name);\n        return updatedPerm || p;\n      })\n    }));\n    \n    setGroupedPermissions(updatedGroups);\n  };\n  \n  const handleSave = async () => {\n    if (!rolePermissions) return;\n    \n    try {\n      const permissionsToSave = rolePermissions.permissions\n        .filter(p => p.isGranted)\n        .map(p => p.name);\n      \n      await updateRolePermissions(rolePermissions.roleId, permissionsToSave);\n      toast.success('Permissions updated successfully');\n      history.push('/roles');\n    } catch (error) {\n      toast.error('Failed to update permissions');\n      console.error(error);\n    }\n  };\n  \n  const handleCancel = () => {\n    history.push('/roles');\n  };\n  \n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  \n  if (!rolePermissions) {\n    return <div>Role not found</div>;\n  }\n  \n  return (\n    <div className=\"content-block\">\n      <h2>Permissions for {rolePermissions.roleName}</h2>\n      \n      {rolePermissions.isSystemRole && (\n        <div className=\"system-role-notice\">\n          This is a system role. System roles automatically have all permissions.\n        </div>\n      )}\n      \n      <div className=\"permissions-container\">\n        {groupedPermissions.map(group => (\n          <div key={group.category} className=\"permission-group\">\n            <h3>{group.category}</h3>\n            <div className=\"permission-list\">\n              {group.permissions.map(permission => (\n                <div key={permission.name} className=\"permission-item\">\n                  <CheckBox\n                    value={permission.isGranted || rolePermissions.isSystemRole}\n                    onValueChanged={e => handlePermissionChange(permission, e.value)}\n                    disabled={rolePermissions.isSystemRole}\n                    text={permission.name.split('.')[1]}\n                  />\n                </div>\n              ))}\n            </div>\n          </div>\n        ))}\n      </div>\n      \n      <div className=\"button-container\">\n        <Button\n          text=\"Save\"\n          type=\"success\"\n          onClick={handleSave}\n          disabled={rolePermissions.isSystemRole}\n        />\n        <Button\n          text=\"Cancel\"\n          onClick={handleCancel}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default PermissionManagement;\n```\n\n2. Add styles for permission management:\n```css\n/* src/styles/PermissionManagement.css */\n.permissions-container {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 20px;\n  margin-top: 20px;\n}\n\n.permission-group {\n  flex: 1 1 300px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  padding: 15px;\n  background-color: #f9f9f9;\n}\n\n.permission-group h3 {\n  margin-top: 0;\n  padding-bottom: 10px;\n  border-bottom: 1px solid #eee;\n}\n\n.permission-list {\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n  margin-top: 10px;\n}\n\n.permission-item {\n  display: flex;\n  align-items: center;\n}\n\n.system-role-notice {\n  background-color: #fff3cd;\n  color: #856404;\n  padding: 10px 15px;\n  border-radius: 4px;\n  margin-bottom: 20px;\n  border: 1px solid #ffeeba;\n}\n\n.button-container {\n  display: flex;\n  gap: 10px;\n  margin-top: 20px;\n  justify-content: flex-end;\n}\n```",
      "testStrategy": "1. Test loading permissions for a role\n2. Verify permissions are correctly grouped by category\n3. Test toggling permissions on and off\n4. Verify view permission is automatically granted when edit permission is selected\n5. Test saving permission changes\n6. Verify system roles show all permissions as granted and disabled\n7. Test navigation back to roles page\n8. Verify error handling and notifications",
      "priority": "medium",
      "dependencies": [
        5,
        6,
        8,
        9
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Login Page",
      "description": "Create a login page with Microsoft-branded login button that redirects to Azure AD for authentication.",
      "details": "1. Create Login page component:\n```tsx\n// src/pages/LoginPage.tsx\nimport React from 'react';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Button } from 'devextreme-react/button';\nimport { useAuth } from '../auth/AuthContext';\nimport './LoginPage.css';\n\nconst LoginPage: React.FC = () => {\n  const { login, isAuthenticated } = useAuth();\n  const history = useHistory();\n  const location = useLocation<{ from: string }>();\n  \n  // Redirect if already authenticated\n  React.useEffect(() => {\n    if (isAuthenticated) {\n      const from = location.state?.from || '/';\n      history.replace(from);\n    }\n  }, [isAuthenticated, history, location]);\n  \n  const handleLogin = async () => {\n    try {\n      await login();\n      // Redirect will happen automatically in the useEffect above\n    } catch (error) {\n      console.error('Login failed', error);\n    }\n  };\n  \n  return (\n    <div className=\"login-container\">\n      <div className=\"login-box\">\n        <h2>FourSPM Application</h2>\n        <p>Please sign in with your organizational account</p>\n        \n        <Button\n          text=\"Sign in with Microsoft\"\n          icon=\"fab fa-microsoft\"\n          type=\"default\"\n          stylingMode=\"contained\"\n          onClick={handleLogin}\n          className=\"ms-login-button\"\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default LoginPage;\n```\n\n2. Add styles for the login page:\n```css\n/* src/pages/LoginPage.css */\n.login-container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  background-color: #f5f5f5;\n}\n\n.login-box {\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  padding: 40px;\n  text-align: center;\n  width: 400px;\n}\n\n.login-box h2 {\n  margin-top: 0;\n  color: #333;\n}\n\n.login-box p {\n  color: #666;\n  margin-bottom: 30px;\n}\n\n.ms-login-button {\n  width: 100%;\n  margin-top: 20px;\n  background-color: #0078d4 !important;\n  border-color: #0078d4 !important;\n}\n\n.ms-login-button:hover {\n  background-color: #106ebe !important;\n  border-color: #106ebe !important;\n}\n```\n\n3. Update the ProtectedRoute component to redirect to login:\n```tsx\n// src/auth/ProtectedRoute.tsx\nimport React from 'react';\nimport { Route, Redirect, RouteProps } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\ninterface ProtectedRouteProps extends RouteProps {\n  requiredPermission?: string;\n}\n\nexport const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ \n  requiredPermission,\n  ...routeProps \n}) => {\n  const { isAuthenticated, userRoles } = useAuth();\n  \n  if (!isAuthenticated) {\n    return (\n      <Redirect \n        to={{\n          pathname: '/login',\n          state: { from: routeProps.location?.pathname }\n        }} \n      />\n    );\n  }\n  \n  // If no specific permission is required, just check authentication\n  if (!requiredPermission) {\n    return <Route {...routeProps} />;\n  }\n  \n  // For system administrators, allow access to everything\n  if (userRoles.includes('Application.Admin')) {\n    return <Route {...routeProps} />;\n  }\n  \n  // For permission-based access, check if user has the required permission\n  // This is a simplified check - in a real app, you'd check against the permissions from the backend\n  return <Route {...routeProps} />;\n};\n```",
      "testStrategy": "1. Test login button triggers MSAL authentication\n2. Verify redirect to Microsoft login page\n3. Test successful login redirects to the intended page\n4. Verify already authenticated users are automatically redirected\n5. Test error handling during authentication failures\n6. Verify the login page styling and responsiveness\n7. Test that protected routes redirect to login when not authenticated",
      "priority": "high",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Frontend Permission Checking",
      "description": "Create a permission checking system for the frontend to conditionally render UI elements based on user permissions.",
      "details": "1. Create a permission context and hook:\n```typescript\n// src/auth/PermissionContext.tsx\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { useAuth } from './AuthContext';\nimport apiClient from '../api/apiClient';\n\ninterface PermissionContextType {\n  userPermissions: string[];\n  hasPermission: (permission: string) => boolean;\n  isLoading: boolean;\n}\n\nconst PermissionContext = createContext<PermissionContextType>({\n  userPermissions: [],\n  hasPermission: () => false,\n  isLoading: true\n});\n\nexport const PermissionProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {\n  const { isAuthenticated, userRoles } = useAuth();\n  const [userPermissions, setUserPermissions] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  \n  useEffect(() => {\n    if (isAuthenticated) {\n      loadUserPermissions();\n    } else {\n      setUserPermissions([]);\n      setIsLoading(false);\n    }\n  }, [isAuthenticated, userRoles]);\n  \n  const loadUserPermissions = async () => {\n    try {\n      setIsLoading(true);\n      const response = await apiClient.get('/user/permissions');\n      setUserPermissions(response.data);\n    } catch (error) {\n      console.error('Failed to load user permissions', error);\n      setUserPermissions([]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  const hasPermission = (permission: string): boolean => {\n    // System administrators have all permissions\n    if (userRoles.includes('Application.Admin')) {\n      return true;\n    }\n    \n    return userPermissions.includes(permission);\n  };\n  \n  return (\n    <PermissionContext.Provider value={{ userPermissions, hasPermission, isLoading }}>\n      {children}\n    </PermissionContext.Provider>\n  );\n};\n\nexport const usePermission = () => useContext(PermissionContext);\n```\n\n2. Create a permission-based component wrapper:\n```typescript\n// src/auth/PermissionGate.tsx\nimport React from 'react';\nimport { usePermission } from './PermissionContext';\n\ninterface PermissionGateProps {\n  permission: string;\n  fallback?: React.ReactNode;\n  children: React.ReactNode;\n}\n\nexport const PermissionGate: React.FC<PermissionGateProps> = ({ \n  permission, \n  fallback = null, \n  children \n}) => {\n  const { hasPermission, isLoading } = usePermission();\n  \n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n  \n  return hasPermission(permission) ? <>{children}</> : <>{fallback}</>;\n};\n```\n\n3. Add a user permissions endpoint to the backend:\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\n[Authorize]\npublic class UserController : ControllerBase\n{\n    private readonly ApplicationDbContext _context;\n    \n    public UserController(ApplicationDbContext context)\n    {\n        _context = context;\n    }\n    \n    [HttpGet(\"permissions\")]\n    public async Task<ActionResult<IEnumerable<string>>> GetUserPermissions()\n    {\n        var userEmail = User.FindFirst(\"preferred_username\")?.Value;\n        if (string.IsNullOrEmpty(userEmail))\n        {\n            return Unauthorized();\n        }\n        \n        // Get user roles from claims\n        var userRoles = User.FindAll(ClaimTypes.Role).Select(c => c.Value.ToLower()).ToList();\n        \n        // Check if user has any system role\n        var systemRoles = await _context.Roles\n            .Where(r => r.IsSystemRole && userRoles.Contains(r.Name.ToLower()))\n            .AnyAsync();\n            \n        if (systemRoles)\n        {\n            // Return all permissions for system roles\n            return Ok(Permissions.GetAllPermissions());\n        }\n        \n        // Get specific permissions for user roles\n        var permissions = await _context.Roles\n            .Where(r => userRoles.Contains(r.Name.ToLower()))\n            .SelectMany(r => r.RolePermissions)\n            .Select(rp => rp.Permission)\n            .Distinct()\n            .ToListAsync();\n            \n        return Ok(permissions);\n    }\n}\n```\n\n4. Update the App component to include the PermissionProvider:\n```typescript\n// src/App.tsx\nimport React, { useEffect } from 'react';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport { AuthProvider } from './auth/AuthContext';\nimport { PermissionProvider } from './auth/PermissionContext';\nimport { setAuthTokenProvider } from './api/apiClient';\nimport Routes from './Routes';\n\nconst App: React.FC = () => {\n  return (\n    <AuthProvider>\n      <PermissionProvider>\n        <Router>\n          <Routes />\n        </Router>\n      </PermissionProvider>\n    </AuthProvider>\n  );\n};\n\nexport default App;\n```\n\n5. Use the PermissionGate in components:\n```typescript\n// Example usage in a component\nimport React from 'react';\nimport { PermissionGate } from '../auth/PermissionGate';\n\nconst SomeComponent: React.FC = () => {\n  return (\n    <div>\n      <h1>Component Title</h1>\n      \n      <PermissionGate permission=\"Projects.View\">\n        <div>This content is only visible to users with Projects.View permission</div>\n      </PermissionGate>\n      \n      <PermissionGate \n        permission=\"Projects.Edit\"\n        fallback={<div>You don't have permission to edit projects</div>}\n      >\n        <button>Edit Project</button>\n      </PermissionGate>\n    </div>\n  );\n};\n```",
      "testStrategy": "1. Test loading user permissions from the backend\n2. Verify permission checking for regular users\n3. Test system role users have access to all permissions\n4. Verify PermissionGate component correctly shows/hides content\n5. Test fallback content is displayed when permission is missing\n6. Verify permission context is updated when authentication state changes\n7. Test error handling when permission loading fails",
      "priority": "medium",
      "dependencies": [
        5,
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Logout Functionality",
      "description": "Create logout functionality that properly terminates the user session and redirects to the login page.",
      "details": "1. Update the AuthContext to include a robust logout function:\n```typescript\n// src/auth/AuthContext.tsx (update the logout function)\nconst logout = async () => {\n  try {\n    // Clear any application state before logout\n    // For example, clear any user-specific data from state management\n    \n    // Call MSAL logout\n    await instance.logoutPopup({\n      postLogoutRedirectUri: window.location.origin,\n      mainWindowRedirectUri: window.location.origin\n    });\n    \n    // Clear any local storage or session storage items if needed\n    // sessionStorage.removeItem('user-settings');\n    \n    // Optionally call a backend endpoint to terminate the session server-side\n    try {\n      await apiClient.post('/auth/logout');\n    } catch (error) {\n      console.warn('Backend logout failed, continuing with client logout', error);\n    }\n  } catch (error) {\n    console.error('Logout failed', error);\n  }\n};\n```\n\n2. Create a logout button component:\n```typescript\n// src/components/LogoutButton.tsx\nimport React from 'react';\nimport { Button } from 'devextreme-react/button';\nimport { useAuth } from '../auth/AuthContext';\n\ninterface LogoutButtonProps {\n  className?: string;\n  text?: string;\n}\n\nconst LogoutButton: React.FC<LogoutButtonProps> = ({ \n  className = '', \n  text = 'Sign Out' \n}) => {\n  const { logout } = useAuth();\n  \n  const handleLogout = async () => {\n    await logout();\n  };\n  \n  return (\n    <Button\n      text={text}\n      icon=\"fas fa-sign-out-alt\"\n      onClick={handleLogout}\n      className={className}\n    />\n  );\n};\n\nexport default LogoutButton;\n```\n\n3. Add a backend logout endpoint (optional, for server-side session termination):\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class AuthController : ControllerBase\n{\n    [HttpPost(\"logout\")]\n    [Authorize]\n    public IActionResult Logout()\n    {\n        // Perform any server-side cleanup needed\n        // For example, revoke refresh tokens, update user's last logout time, etc.\n        \n        return Ok(new { message = \"Logout successful\" });\n    }\n}\n```\n\n4. Add the logout button to the application header:\n```typescript\n// src/components/Header.tsx\nimport React from 'react';\nimport { Toolbar, Item } from 'devextreme-react/toolbar';\nimport { useAuth } from '../auth/AuthContext';\nimport LogoutButton from './LogoutButton';\nimport './Header.css';\n\nconst Header: React.FC = () => {\n  const { isAuthenticated } = useAuth();\n  \n  return (\n    <header className=\"header\">\n      <Toolbar>\n        <Item\n          location=\"before\"\n          widget=\"dxButton\"\n          options={{\n            icon: 'menu',\n            onClick: () => {\n              // Toggle sidebar if you have one\n            }\n          }}\n        />\n        \n        <Item\n          location=\"before\"\n          cssClass=\"app-name\"\n          text=\"FourSPM Application\"\n        />\n        \n        <Item\n          location=\"after\"\n          locateInMenu=\"auto\"\n        >\n          {isAuthenticated && <LogoutButton />}\n        </Item>\n      </Toolbar>\n    </header>\n  );\n};\n\nexport default Header;\n```\n\n5. Add styles for the header:\n```css\n/* src/components/Header.css */\n.header {\n  background-color: #f8f9fa;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n  position: sticky;\n  top: 0;\n  z-index: 1000;\n}\n\n.app-name {\n  font-size: 1.2rem;\n  font-weight: 500;\n  margin-left: 10px;\n}\n```",
      "testStrategy": "1. Test logout button triggers MSAL logout\n2. Verify user is redirected to login page after logout\n3. Test that authentication state is properly cleared\n4. Verify backend logout endpoint is called\n5. Test that local storage/session storage items are cleared\n6. Verify logout works from different pages of the application\n7. Test error handling during logout failures",
      "priority": "high",
      "dependencies": [
        5,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Silent Authentication",
      "description": "Implement silent authentication to automatically authenticate returning users with active sessions.",
      "details": "1. Update the AuthContext to include silent authentication:\n```typescript\n// src/auth/AuthContext.tsx (update with silent auth)\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { useMsal, useAccount } from '@azure/msal-react';\nimport { InteractionStatus, InteractionRequiredAuthError } from '@azure/msal-browser';\nimport { loginRequest } from './msalConfig';\n\ninterface AuthContextType {\n  isAuthenticated: boolean;\n  login: () => Promise<void>;\n  logout: () => Promise<void>;\n  getToken: () => Promise<string | null>;\n  userRoles: string[];\n  isLoading: boolean;\n}\n\nconst AuthContext = createContext<AuthContextType>(null!);\n\nexport const AuthProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {\n  const { instance, accounts, inProgress } = useMsal();\n  const account = useAccount(accounts[0] || {});\n  const [userRoles, setUserRoles] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  \n  const attemptSilentLogin = useCallback(async () => {\n    if (!account && inProgress === InteractionStatus.None) {\n      try {\n        // Try silent login\n        await instance.ssoSilent(loginRequest);\n      } catch (error) {\n        if (error instanceof InteractionRequiredAuthError) {\n          // Silent login failed, user needs to login interactively\n          console.log('Silent login failed, user needs to login interactively');\n        } else {\n          console.error('Silent login failed with unexpected error', error);\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    } else {\n      setIsLoading(false);\n    }\n  }, [account, inProgress, instance]);\n  \n  useEffect(() => {\n    attemptSilentLogin();\n  }, [attemptSilentLogin]);\n  \n  useEffect(() => {\n    if (account && account.idTokenClaims) {\n      // Extract roles from token claims\n      const roles = account.idTokenClaims.roles || [];\n      setUserRoles(roles);\n    }\n  }, [account]);\n  \n  const login = async () => {\n    try {\n      await instance.loginPopup(loginRequest);\n    } catch (error) {\n      console.error('Login failed', error);\n    }\n  };\n  \n  const logout = async () => {\n    try {\n      await instance.logoutPopup({\n        postLogoutRedirectUri: window.location.origin,\n        mainWindowRedirectUri: window.location.origin\n      });\n    } catch (error) {\n      console.error('Logout failed', error);\n    }\n  };\n  \n  const getToken = async (): Promise<string | null> => {\n    if (!account) return null;\n    \n    try {\n      const response = await instance.acquireTokenSilent({\n        ...loginRequest,\n        account: account\n      });\n      return response.accessToken;\n    } catch (error) {\n      if (error instanceof InteractionRequiredAuthError) {\n        // Token acquisition requires interaction, fallback to interactive method\n        try {\n          const response = await instance.acquireTokenPopup({\n            ...loginRequest,\n            account: account\n          });\n          return response.accessToken;\n        } catch (interactiveError) {\n          console.error('Interactive token acquisition failed', interactiveError);\n          return null;\n        }\n      }\n      console.error('Token acquisition failed', error);\n      return null;\n    }\n  };\n  \n  const value = {\n    isAuthenticated: !!account,\n    login,\n    logout,\n    getToken,\n    userRoles,\n    isLoading\n  };\n  \n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n```\n\n2. Create a loading component to show during authentication:\n```typescript\n// src/components/LoadingOverlay.tsx\nimport React from 'react';\nimport { LoadPanel } from 'devextreme-react/load-panel';\n\ninterface LoadingOverlayProps {\n  visible: boolean;\n  message?: string;\n}\n\nconst LoadingOverlay: React.FC<LoadingOverlayProps> = ({ \n  visible, \n  message = 'Loading...' \n}) => {\n  return (\n    <LoadPanel\n      visible={visible}\n      message={message}\n      showIndicator={true}\n      shading={true}\n      shadingColor=\"rgba(0, 0, 0, 0.4)\"\n    />\n  );\n};\n\nexport default LoadingOverlay;\n```\n\n3. Update the App component to show loading during authentication:\n```typescript\n// src/App.tsx\nimport React from 'react';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport { AuthProvider, useAuth } from './auth/AuthContext';\nimport { PermissionProvider } from './auth/PermissionContext';\nimport { setAuthTokenProvider } from './api/apiClient';\nimport Routes from './Routes';\nimport LoadingOverlay from './components/LoadingOverlay';\n\nconst AppContent: React.FC = () => {\n  const { getToken, isLoading } = useAuth();\n  \n  React.useEffect(() => {\n    setAuthTokenProvider(getToken);\n  }, [getToken]);\n  \n  return (\n    <>\n      <LoadingOverlay visible={isLoading} message=\"Authenticating...\" />\n      <Router>\n        <Routes />\n      </Router>\n    </>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <AuthProvider>\n      <PermissionProvider>\n        <AppContent />\n      </PermissionProvider>\n    </AuthProvider>\n  );\n};\n\nexport default App;\n```\n\n4. Update the Login page to handle loading state:\n```typescript\n// src/pages/LoginPage.tsx (update)\nimport React from 'react';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Button } from 'devextreme-react/button';\nimport { useAuth } from '../auth/AuthContext';\nimport './LoginPage.css';\n\nconst LoginPage: React.FC = () => {\n  const { login, isAuthenticated, isLoading } = useAuth();\n  const history = useHistory();\n  const location = useLocation<{ from: string }>();\n  \n  // Redirect if already authenticated\n  React.useEffect(() => {\n    if (isAuthenticated && !isLoading) {\n      const from = location.state?.from || '/';\n      history.replace(from);\n    }\n  }, [isAuthenticated, isLoading, history, location]);\n  \n  const handleLogin = async () => {\n    try {\n      await login();\n      // Redirect will happen automatically in the useEffect above\n    } catch (error) {\n      console.error('Login failed', error);\n    }\n  };\n  \n  // Don't render login page while still checking for silent auth\n  if (isLoading) {\n    return null;\n  }\n  \n  return (\n    <div className=\"login-container\">\n      <div className=\"login-box\">\n        <h2>FourSPM Application</h2>\n        <p>Please sign in with your organizational account</p>\n        \n        <Button\n          text=\"Sign in with Microsoft\"\n          icon=\"fab fa-microsoft\"\n          type=\"default\"\n          stylingMode=\"contained\"\n          onClick={handleLogin}\n          className=\"ms-login-button\"\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default LoginPage;\n```",
      "testStrategy": "1. Test silent authentication for users with active sessions\n2. Verify loading state is displayed during authentication\n3. Test fallback to interactive login when silent auth fails\n4. Verify token refresh happens automatically\n5. Test error handling during silent authentication\n6. Verify user is not prompted to login when they have an active session\n7. Test that authentication state is properly maintained across page reloads",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Enhance AuthContext to Attempt Silent Login on Initialization",
          "description": "Modify the AuthContext provider to automatically attempt a silent login when the application initializes, using MSAL's ssoSilent or equivalent method. Ensure that the context exposes authentication state and any relevant user information.",
          "dependencies": [],
          "details": "Implement logic in the AuthContext to call the silent authentication method (e.g., msalInstance.ssoSilent) on mount. Handle possible errors, such as InteractionRequiredAuthError, and update the context state accordingly.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Token Refresh Logic with Fallback to Interactive Authentication",
          "description": "Add logic to refresh tokens when they expire, attempting silent token acquisition first and falling back to interactive authentication if required.",
          "dependencies": [
            1
          ],
          "details": "Use MSAL's acquireTokenSilent method to refresh tokens. If an InteractionRequiredAuthError is thrown, prompt the user for interactive authentication (e.g., loginPopup). Ensure robust error handling for various authentication scenarios.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create a Loading Component to Display During Authentication",
          "description": "Develop a reusable loading UI component that is shown while authentication or token refresh is in progress.",
          "dependencies": [
            1
          ],
          "details": "Design a simple loading spinner or progress indicator. Integrate it with the AuthContext so that it displays whenever authentication state is loading or being determined.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Update Application Components to Handle Authentication Loading States",
          "description": "Refactor application components to use the AuthContext's loading state, displaying the loading component as needed and ensuring proper handling of authenticated and unauthenticated states.",
          "dependencies": [
            1,
            3
          ],
          "details": "Update components to check the authentication loading state from AuthContext. Show the loading component during authentication, and render protected content only when authentication is complete.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 15,
      "title": "Implement Home Page and Unauthorized Access Handling",
      "description": "Create a home page that is accessible to authenticated users and implement handling for unauthorized access attempts.",
      "details": "1. Create a home page component:\n```typescript\n// src/pages/HomePage.tsx\nimport React from 'react';\nimport { useAuth } from '../auth/AuthContext';\nimport { usePermission } from '../auth/PermissionContext';\nimport { PermissionGate } from '../auth/PermissionGate';\n\nconst HomePage: React.FC = () => {\n  const { userRoles } = useAuth();\n  \n  return (\n    <div className=\"content-block\">\n      <h2>Welcome to FourSPM Application</h2>\n      \n      <div className=\"user-info\">\n        <h3>Your Access Information</h3>\n        <p>You have the following roles:</p>\n        <ul>\n          {userRoles.length > 0 ? (\n            userRoles.map((role, index) => (\n              <li key={index}>{role}</li>\n            ))\n          ) : (\n            <li>No roles assigned</li>\n          )}\n        </ul>\n      </div>\n      \n      <div className=\"quick-links\">\n        <h3>Quick Links</h3>\n        \n        <PermissionGate permission=\"Roles.View\">\n          <div className=\"link-card\">\n            <h4>Role Management</h4>\n            <p>Manage application roles and permissions</p>\n            <a href=\"/roles\">Go to Role Management</a>\n          </div>\n        </PermissionGate>\n        \n        {/* Add other quick links based on permissions */}\n      </div>\n    </div>\n  );\n};\n\nexport default HomePage;\n```\n\n2. Create an unauthorized access page:\n```typescript\n// src/pages/UnauthorizedPage.tsx\nimport React from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { Button } from 'devextreme-react/button';\n\nconst UnauthorizedPage: React.FC = () => {\n  const history = useHistory();\n  \n  const goToHome = () => {\n    history.push('/');\n  };\n  \n  return (\n    <div className=\"content-block unauthorized-page\">\n      <div className=\"unauthorized-container\">\n        <h2>Access Denied</h2>\n        <p>You don't have permission to access this page.</p>\n        <p>Please contact your administrator if you believe this is an error.</p>\n        \n        <Button\n          text=\"Go to Home Page\"\n          type=\"default\"\n          onClick={goToHome}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default UnauthorizedPage;\n```\n\n3. Update the ProtectedRoute component to handle unauthorized access:\n```typescript\n// src/auth/ProtectedRoute.tsx (update)\nimport React from 'react';\nimport { Route, Redirect, RouteProps } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\nimport { usePermission } from './PermissionContext';\n\ninterface ProtectedRouteProps extends RouteProps {\n  requiredPermission?: string;\n}\n\nexport const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ \n  requiredPermission,\n  ...routeProps \n}) => {\n  const { isAuthenticated, isLoading } = useAuth();\n  const { hasPermission } = usePermission();\n  \n  // Show nothing while authentication is being checked\n  if (isLoading) {\n    return null;\n  }\n  \n  // Redirect to login if not authenticated\n  if (!isAuthenticated) {\n    return (\n      <Redirect \n        to={{\n          pathname: '/login',\n          state: { from: routeProps.location?.pathname }\n        }} \n      />\n    );\n  }\n  \n  // If no specific permission is required, just check authentication\n  if (!requiredPermission) {\n    return <Route {...routeProps} />;\n  }\n  \n  // Check if user has the required permission\n  if (!hasPermission(requiredPermission)) {\n    return <Redirect to=\"/unauthorized\" />;\n  }\n  \n  // User has the required permission\n  return <Route {...routeProps} />;\n};\n```\n\n4. Update the Routes component to include the unauthorized page:\n```typescript\n// src/Routes.tsx (update)\nimport React from 'react';\nimport { Switch, Route, Redirect } from 'react-router-dom';\nimport { ProtectedRoute } from './auth/ProtectedRoute';\nimport LoginPage from './pages/LoginPage';\nimport HomePage from './pages/HomePage';\nimport UnauthorizedPage from './pages/UnauthorizedPage';\nimport RoleManagement from './pages/RoleManagement';\nimport PermissionManagement from './pages/PermissionManagement';\n\nconst Routes: React.FC = () => {\n  return (\n    <Switch>\n      <Route path=\"/login\" component={LoginPage} />\n      <Route path=\"/unauthorized\" component={UnauthorizedPage} />\n      <ProtectedRoute exact path=\"/\" component={HomePage} />\n      <ProtectedRoute \n        path=\"/roles\" \n        exact \n        component={RoleManagement} \n        requiredPermission=\"Roles.View\" \n      />\n      <ProtectedRoute \n        path=\"/roles/:id/permissions\" \n        component={PermissionManagement} \n        requiredPermission=\"Roles.Edit\" \n      />\n      <Redirect to=\"/\" />\n    </Switch>\n  );\n};\n\nexport default Routes;\n```\n\n5. Add styles for the home and unauthorized pages:\n```css\n/* src/pages/HomePage.css */\n.user-info {\n  background-color: #f8f9fa;\n  border-radius: 8px;\n  padding: 20px;\n  margin-bottom: 30px;\n}\n\n.quick-links {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 20px;\n}\n\n.link-card {\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  padding: 20px;\n  width: 300px;\n  transition: transform 0.2s, box-shadow 0.2s;\n}\n\n.link-card:hover {\n  transform: translateY(-5px);\n  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n}\n\n.link-card h4 {\n  margin-top: 0;\n  color: #333;\n}\n\n.link-card a {\n  display: inline-block;\n  margin-top: 10px;\n  color: #0078d4;\n  text-decoration: none;\n}\n\n.link-card a:hover {\n  text-decoration: underline;\n}\n\n/* src/pages/UnauthorizedPage.css */\n.unauthorized-page {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: calc(100vh - 60px); /* Adjust based on header height */\n}\n\n.unauthorized-container {\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  padding: 40px;\n  text-align: center;\n  max-width: 500px;\n}\n\n.unauthorized-container h2 {\n  color: #d32f2f;\n  margin-top: 0;\n}\n```",
      "testStrategy": "1. Test home page displays correctly for authenticated users\n2. Verify user roles are displayed correctly\n3. Test quick links are shown/hidden based on permissions\n4. Verify unauthorized page is displayed when accessing restricted content\n5. Test navigation from unauthorized page to home page\n6. Verify protected routes redirect to unauthorized page when permission is missing\n7. Test that home page is accessible without specific permissions",
      "priority": "medium",
      "dependencies": [
        5,
        12
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}